<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/images/favicon/favicon.ico"/><meta name="og:title" content="Alex Gurvich, Ph.D."/><meta name="twitter:card" content="summary_large_image"/><link rel="preload" as="image" href="/images/alex-gurvich.png"/><title>Exploring Gaia DR3 with Firefly</title><link rel="preload" as="image" href="/images/firefly/gaia_lane.png"/><meta name="next-head-count" content="8"/><link rel="stylesheet" href="fonts/font-awesome/css/font-awesome.min.css"/><link rel="stylesheet" href="/css/content.css"/><link rel="preload" href="/_next/static/css/0ffd2ccf29573836.css" as="style"/><link rel="stylesheet" href="/_next/static/css/0ffd2ccf29573836.css" data-n-g=""/><link rel="preload" href="/_next/static/css/81c937b40bc6530e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/81c937b40bc6530e.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/_next/static/chunks/main-481ef0d25a716735.js" defer=""></script><script src="/_next/static/chunks/pages/_app-2dfd096757008a0f.js" defer=""></script><script src="/_next/static/chunks/562-a1eeb3a9742102fe.js" defer=""></script><script src="/_next/static/chunks/pages/%5Bid%5D-cfd94295db71fdf7.js" defer=""></script><script src="/_next/static/el4lPvfLG2MCFYhy_sTSp/_buildManifest.js" defer=""></script><script src="/_next/static/el4lPvfLG2MCFYhy_sTSp/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="layout_container__fbLkO"><aside class="layout_sidebar__AY6x8"><header class="layout_header__kY0Lt"><a href="/"><img alt="" width="100" height="100" decoding="async" data-nimg="1" class="layout_profilePicture__kIjzH" style="color:transparent" src="/images/alex-gurvich.png"/></a><div class="layout_titleName__HKogh">Alex Gurvich</div><div style="margin-top:25px"><hr style="width:25%"/>data-viz specialist <br/><a href="https://science.gsfc.nasa.gov/sed/bio/alexander.b.gurvich" target="_blank"> NASA Goddard </a>&amp; <a href="https://svs.gsfc.nasa.gov/" target="_blank"> SVS </a><hr style="width:25%"/>HPC &amp; fullstack web software dev<hr style="width:25%"/>Ph.D. Computational Astrophysics &amp; Data Visualization</div></header><footer class="layout_footer__dka_2"><section><div class="contact_myh3__W6Onk"> Find me </div><ul class="contact_list__6GU4P"><li class="contact_listItem__j7iuj"><a href="https://www.twitter.com/alexbgurvich" target="_blank"><i class="fa fa-twitter"></i></a></li><li class="contact_listItem__j7iuj"><a href="https://www.linkedin.com/in/alex-b-gurvich" target="_blank"><i class="fa fa-linkedin"></i></a></li><li class="contact_listItem__j7iuj"><a href="https://www.github.com/agurvich" target="_blank"><i class="fa fa-github"></i></a></li><li class="contact_listItem__j7iuj"><a href="mailto:alex.b.gurvich@gmail.com" target="_blank"><i class="fa fa-envelope-o"></i></a></li></ul></section><section>2023<!-- --> © <!-- -->Alex Gurvich</section></footer></aside><main class="layout_content__563Cv"><div class="post_post___H4tn"><div><img resizemode="cover" alt="" width="1000" height="500" decoding="async" data-nimg="1" class="post_header__Y5oP6" style="color:transparent" src="/images/firefly/gaia_lane.png"/><div class="post_title__aQveY">Exploring Gaia DR3 with Firefly</div><div class="post_date__3834l"><time dateTime="2023-03-16 01:00:00-06:00">March 16, 2023</time><div> <!-- -->I designed a massively parallel algorithm and progressive rendering scheme in order to interactively visualize all 1.5 billion+ stars observed by the Gaia satellite.<!-- --> </div></div><div class="post_content__PPM5L"><p>This is accomplished using a novel data indexing scheme in the PDPP that links the data's position in realspace to its location on disk using an octree.
Using this method, we have visualized all of the stars in Gaia DR3, just over one billion stars.
Its custom-built octree render engine allows for the exploration of datasets with billions of particles, ensuring smooth navigation even with massive datasets.</p>
<p>For handling large datasets, Firefly utilizes a progressive rendering scheme that loads data within the camera's field of view.
This is achieved through a novel data indexing scheme in the PDPP, linking the data's position in realspace to its location on disk using an octree.
This method has been used to visualize all of the stars in Gaia DR3, totaling over one billion stars.</p>
<p>The Gaia DR3 dataset, containing the positions of approximately 1.5 billion stars in the Milky Way, is a massive trove of information that can be challenging to visualize interactively. Firefly, our powerful data visualization tool, can now tackle this problem by employing a progressive rendering scheme based on octrees. In this blog post, we will discuss how Firefly uses octrees to visualize very large datasets and explore the algorithm implemented in the Python Data Processing Pipeline (PDPP) to build the octree.</p>
<h1 id="octrees-for-efficient-visualization">Octrees for Efficient Visualization</h1>
<p>To visualize large datasets without overwhelming the browser's memory, Firefly selectively loads data in proximity to and within the camera's view. This is achieved by pre-formatting the data as an octree using the PDPP and saving the octree files to disk. An octree is a tree data structure that recursively divides 3D space into smaller octants, making it an efficient way to represent spatially partitioned data. Employing an octree significantly improves performance, reduces start-up time, and allows the visualization domain to scale effectively.</p>
<p>While pre-formatting data as an octree can be computationally expensive and requires saving the data to disk, the benefits of visualizing large datasets that would otherwise be inaccessible to interactive visualization techniques outweigh these drawbacks.</p>
<h1 id="building-the-octree-using-the-pdpp">Building the Octree Using the PDPP</h1>
<figure class="left-figure">
    <img src="images/octree_800px.png"/>
    <caption>
    Schematic of an octree recursively partitioning space (left) and the corresponding tree structure (right).
    Image by Wikipedia user <a href=&quot;//commons.wikimedia.org/wiki/User:WhiteTimberwolf&quot; title=&quot;User:WhiteTimberwolf&quot> WhiteTimberwolf</a>, PNG version: <a href=&quot;https://de.wikipedia.org/wiki/User:N%C3%BC&quot; class=&quot;extiw&quot; title=&quot;de:User:Nü&quot;> Nü</a> - <span class=&quot;int-own-work&quot; lang=&quot;en&quot;>Own work</span>, <a href="http://creativecommons.org/licenses/by-sa/3.0/" title="Creative Commons Attribution-Share Alike 3.0">CC BY-SA 3.0</a>, <a href="https://commons.wikimedia.org/w/index.php?curid=9851485">Link</a>
    </caption>
</figure>
<p>To create an octree, we typically group particles into nodes containing between 10^4 and 10^5 particles each. The minimum and maximum number of particles per node can be chosen by the user. During tree construction, we also accumulate aggregate statistics, such as total mass and mass-weighted scalar fields. This way, each node in the octree holds aggregate data representing the node on average and buffer data it is responsible for storing.</p>
<p>The algorithm begins by measuring the extent of the 99% of particles closest to the center of the dataset to define the bounding box of the root node. The remaining 1% of particles is held until the octree is constructed and added as buffer data to the root node to minimize the effect of outliers on the tree structure. Particles are then sorted into the eight sub-octants of the root node. Any sub-octant containing more particles than the maximum allowable number per node overflows, and the buffer particles are sorted into the eight sub-octants of that node. The octree is spatially refined as particles are iteratively sorted by recursively applying the maximum-threshold-to-overflow criteria for each of the resulting eight child nodes.</p>
<p>To reduce the number of extraneous nodes with only a few particles, we prune the octree by merging child nodes below the minimum required particles per node back into their parents. This process can result in a node having both buffer particle data and children due to the inherent asymmetry in the dataset's coordinates.</p>
<p>The octree build implementation is optimized for extremely large datasets, can be run in parallel using multiple threads, and does not require loading the entire dataset into memory. The PDPP saves the octree's particle data in binary format and creates a JSON file for Firefly containing the octree structure, accumulated aggregate data for each node, and the locations of the node centers and centers of mass.</p>
<h1 id="implementing-an-octree-in-firefly">Implementing an Octree in Firefly</h1>
<p>In the Firefly web application, an octree is represented as a Javascript object defined by the octree JSON file from PDPP. Each node contains pointers to the files on disk, byte sizes, and byte offsets of its buffer data, along with its center of mass, accumulated aggregate data, bounding box, and list of children.</p>
<p>During the render loop, material and geometry mesh objects are dynamically created and filled with buffer data when nodes are opened. The process of updating the octree in the render loop is handled asynchronously to maintain the interactivity of the application. Each octree has its own "draw" and "remove" queues, and the particle data is loaded or purged based on the camera's view and proximity to the nodes.</p>
<p>At each render pass, if the draw queue is not empty and not locked, the node nearest to the camera is selected and the queue is locked. The particle data associated with that node is then loaded from the corresponding binary file and the node is removed from the draw queue. Once the data is loaded, new material and geometry objects are created, and the loaded data is copied into their buffers. The geometry mesh is then added to the scene and the draw queue is unlocked.</p>
<p>The remove queue is emptied at each render pass, disposing of material and geometry objects and freeing up Javascript array data. After updating the draw and remove queues, we walk through the current particle group's octree, deciding whether a node should be opened, closed, or ignored. If a node is on screen and covers more than one pixel from the camera perspective, it is added to the draw queue. If a node has already been drawn but subtends less than one pixel on screen, it is added to the remove queue. Nodes added to either queue are removed from their older opposing queue as necessary.</p>
<p>Through this approach, Firefly can render and interactively explore exceptionally large datasets. For example, we have successfully visualized nearly 1.5 x 10^9 stars from Gaia DR3 in real-time using an octree. As datasets continue to grow, Firefly's octree rendering method will be an invaluable tool for data exploration and public outreach.</p>
<h1 id="conclusion">Conclusion</h1>
<p>The power of octrees has enabled Firefly to efficiently visualize massive datasets such as Gaia DR3. By using a progressive rendering scheme based on octrees, we can dynamically load data depending on the camera's view, significantly improving performance and reducing memory usage. With the implementation of octrees in Firefly, researchers and enthusiasts alike can now interactively explore some of the largest datasets in astronomy, opening up new avenues for discovery and education.</p></div></div><aside> <ul class="postGrid_tagList__1KHV3"><a href="/tags/astronomy"><li class="postGrid_tagItem__bWBH3">#astronomy</li></a><a href="/tags/dataviz"><li class="postGrid_tagItem__bWBH3">#dataviz</li></a></ul> </aside></div><div class="layout_backToHome__9sjx_"><a href="/">← Back to home</a></div></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"firefly-gaia-dr3","contentHtml":"\u003cp\u003eThis is accomplished using a novel data indexing scheme in the PDPP that links the data's position in realspace to its location on disk using an octree.\nUsing this method, we have visualized all of the stars in Gaia DR3, just over one billion stars.\nIts custom-built octree render engine allows for the exploration of datasets with billions of particles, ensuring smooth navigation even with massive datasets.\u003c/p\u003e\n\u003cp\u003eFor handling large datasets, Firefly utilizes a progressive rendering scheme that loads data within the camera's field of view.\nThis is achieved through a novel data indexing scheme in the PDPP, linking the data's position in realspace to its location on disk using an octree.\nThis method has been used to visualize all of the stars in Gaia DR3, totaling over one billion stars.\u003c/p\u003e\n\u003cp\u003eThe Gaia DR3 dataset, containing the positions of approximately 1.5 billion stars in the Milky Way, is a massive trove of information that can be challenging to visualize interactively. Firefly, our powerful data visualization tool, can now tackle this problem by employing a progressive rendering scheme based on octrees. In this blog post, we will discuss how Firefly uses octrees to visualize very large datasets and explore the algorithm implemented in the Python Data Processing Pipeline (PDPP) to build the octree.\u003c/p\u003e\n\u003ch1 id=\"octrees-for-efficient-visualization\"\u003eOctrees for Efficient Visualization\u003c/h1\u003e\n\u003cp\u003eTo visualize large datasets without overwhelming the browser's memory, Firefly selectively loads data in proximity to and within the camera's view. This is achieved by pre-formatting the data as an octree using the PDPP and saving the octree files to disk. An octree is a tree data structure that recursively divides 3D space into smaller octants, making it an efficient way to represent spatially partitioned data. Employing an octree significantly improves performance, reduces start-up time, and allows the visualization domain to scale effectively.\u003c/p\u003e\n\u003cp\u003eWhile pre-formatting data as an octree can be computationally expensive and requires saving the data to disk, the benefits of visualizing large datasets that would otherwise be inaccessible to interactive visualization techniques outweigh these drawbacks.\u003c/p\u003e\n\u003ch1 id=\"building-the-octree-using-the-pdpp\"\u003eBuilding the Octree Using the PDPP\u003c/h1\u003e\n\u003cfigure class=\"left-figure\"\u003e\n    \u003cimg src=\"images/octree_800px.png\"/\u003e\n    \u003ccaption\u003e\n    Schematic of an octree recursively partitioning space (left) and the corresponding tree structure (right).\n    Image by Wikipedia user \u003ca href=\u0026quot;//commons.wikimedia.org/wiki/User:WhiteTimberwolf\u0026quot; title=\u0026quot;User:WhiteTimberwolf\u0026quot\u003e WhiteTimberwolf\u003c/a\u003e, PNG version: \u003ca href=\u0026quot;https://de.wikipedia.org/wiki/User:N%C3%BC\u0026quot; class=\u0026quot;extiw\u0026quot; title=\u0026quot;de:User:Nü\u0026quot;\u003e Nü\u003c/a\u003e - \u003cspan class=\u0026quot;int-own-work\u0026quot; lang=\u0026quot;en\u0026quot;\u003eOwn work\u003c/span\u003e, \u003ca href=\"http://creativecommons.org/licenses/by-sa/3.0/\" title=\"Creative Commons Attribution-Share Alike 3.0\"\u003eCC BY-SA 3.0\u003c/a\u003e, \u003ca href=\"https://commons.wikimedia.org/w/index.php?curid=9851485\"\u003eLink\u003c/a\u003e\n    \u003c/caption\u003e\n\u003c/figure\u003e\n\u003cp\u003eTo create an octree, we typically group particles into nodes containing between 10^4 and 10^5 particles each. The minimum and maximum number of particles per node can be chosen by the user. During tree construction, we also accumulate aggregate statistics, such as total mass and mass-weighted scalar fields. This way, each node in the octree holds aggregate data representing the node on average and buffer data it is responsible for storing.\u003c/p\u003e\n\u003cp\u003eThe algorithm begins by measuring the extent of the 99% of particles closest to the center of the dataset to define the bounding box of the root node. The remaining 1% of particles is held until the octree is constructed and added as buffer data to the root node to minimize the effect of outliers on the tree structure. Particles are then sorted into the eight sub-octants of the root node. Any sub-octant containing more particles than the maximum allowable number per node overflows, and the buffer particles are sorted into the eight sub-octants of that node. The octree is spatially refined as particles are iteratively sorted by recursively applying the maximum-threshold-to-overflow criteria for each of the resulting eight child nodes.\u003c/p\u003e\n\u003cp\u003eTo reduce the number of extraneous nodes with only a few particles, we prune the octree by merging child nodes below the minimum required particles per node back into their parents. This process can result in a node having both buffer particle data and children due to the inherent asymmetry in the dataset's coordinates.\u003c/p\u003e\n\u003cp\u003eThe octree build implementation is optimized for extremely large datasets, can be run in parallel using multiple threads, and does not require loading the entire dataset into memory. The PDPP saves the octree's particle data in binary format and creates a JSON file for Firefly containing the octree structure, accumulated aggregate data for each node, and the locations of the node centers and centers of mass.\u003c/p\u003e\n\u003ch1 id=\"implementing-an-octree-in-firefly\"\u003eImplementing an Octree in Firefly\u003c/h1\u003e\n\u003cp\u003eIn the Firefly web application, an octree is represented as a Javascript object defined by the octree JSON file from PDPP. Each node contains pointers to the files on disk, byte sizes, and byte offsets of its buffer data, along with its center of mass, accumulated aggregate data, bounding box, and list of children.\u003c/p\u003e\n\u003cp\u003eDuring the render loop, material and geometry mesh objects are dynamically created and filled with buffer data when nodes are opened. The process of updating the octree in the render loop is handled asynchronously to maintain the interactivity of the application. Each octree has its own \"draw\" and \"remove\" queues, and the particle data is loaded or purged based on the camera's view and proximity to the nodes.\u003c/p\u003e\n\u003cp\u003eAt each render pass, if the draw queue is not empty and not locked, the node nearest to the camera is selected and the queue is locked. The particle data associated with that node is then loaded from the corresponding binary file and the node is removed from the draw queue. Once the data is loaded, new material and geometry objects are created, and the loaded data is copied into their buffers. The geometry mesh is then added to the scene and the draw queue is unlocked.\u003c/p\u003e\n\u003cp\u003eThe remove queue is emptied at each render pass, disposing of material and geometry objects and freeing up Javascript array data. After updating the draw and remove queues, we walk through the current particle group's octree, deciding whether a node should be opened, closed, or ignored. If a node is on screen and covers more than one pixel from the camera perspective, it is added to the draw queue. If a node has already been drawn but subtends less than one pixel on screen, it is added to the remove queue. Nodes added to either queue are removed from their older opposing queue as necessary.\u003c/p\u003e\n\u003cp\u003eThrough this approach, Firefly can render and interactively explore exceptionally large datasets. For example, we have successfully visualized nearly 1.5 x 10^9 stars from Gaia DR3 in real-time using an octree. As datasets continue to grow, Firefly's octree rendering method will be an invaluable tool for data exploration and public outreach.\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eThe power of octrees has enabled Firefly to efficiently visualize massive datasets such as Gaia DR3. By using a progressive rendering scheme based on octrees, we can dynamically load data depending on the camera's view, significantly improving performance and reducing memory usage. With the implementation of octrees in Firefly, researchers and enthusiasts alike can now interactively explore some of the largest datasets in astronomy, opening up new avenues for discovery and education.\u003c/p\u003e","layout":"post","title":"Exploring Gaia DR3 with Firefly","date":"2023-03-16 01:00:00-06:00","description":"I designed a massively parallel algorithm and progressive rendering scheme in order to interactively visualize all 1.5 billion+ stars observed by the Gaia satellite.","img":"firefly/gaia_lane.png","tags":["dataviz","astronomy"]}},"__N_SSG":true},"page":"/[id]","query":{"id":"firefly-gaia-dr3"},"buildId":"el4lPvfLG2MCFYhy_sTSp","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>